<!--
  Copyright [2023] [Coordinated Chaos]
 
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at
 
      http://www.apache.org/licenses/LICENSE-2.0
 
  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 -->
<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Dev Docs</title>
    </head>
    <body>
        <h1>Dev Docs</h1>
        <h2>How to run</h2>
        <div>
            <p>System Requirements</p>
            <ul>
                <li>
                    <a href="https://www.docker.com/products/docker-desktop/"
                        >Docker</a
                    >
                </li>
            </ul>
            <p>
                First of all create a local MongoDB instance, this can be done
                in docker with the following command:
            </p>
            <code
                >docker run --name MongoDB -p 27017:27017 -d mongo:latest</code
            >
            <p>
                Then rename the <code>.env.template</code> file to
                <code>.env</code> the example values will allow the application
                if you have set up your database as shown above, however the
                file upload will not work without a valid Azure connection
                string.
            </p>
            <p>
                Once you have done this, the project includes build scripts for
                Windows (<code>build.bat</code>) and Linux
                (<code>build.sh</code>). Running this file will build the docker
                image, remove any existing containers, ensure the database is
                running and then run the new image.The app will then be
                available on port 3000 (<a href="http://localhost:3000"
                    >http://localhost:3000</a
                >).
            </p>
            <p>
                This works without needing to install NodeJS or the project
                dependencies as the docker image uses the Node image and
                installs the dependencies within it.
            </p>
        </div>
        <h2>How to test</h2>
        <div>
            <p>System Requirements</p>
            <ul>
                <li>
                    <a href="https://nodejs.org/en">NodeJS v20</a>
                </li>
            </ul>
            <p>
                To install the dependencies needed to run the application and
                test it outside of docker, run <code>npm install</code>
            </p>
            <p>
                Then you can run <code>npm test</code> to run the unit tests.
                You will see the results in the terminal.
            </p>
        </div>
        <h2>How to deploy</h2>
        <div>
            <p>
                The deployment happens automatically when code is merged into
                the main branch.
            </p>
            <p>The GitHub CI/CD deployment pipeline runs as follows:</p>
            <ol>
                <li>The code is checked out</li>
                <li>It logs into our private Azure container registry</li>
                <li>It builds the docker image</li>
                <li>It pushes the docker image to the container registry</li>
                <li>
                    It SSH's onto the deployment server as the "deploy" user
                </li>
                <li>It runs the update script</li>
            </ol>
            <p>
                On the server in the "deploy" users directory are 2 files, the
                <code>compose.yml</code> file and the
                <code>update.sh</code> file.
            </p>
            <p>
                The update file just runs
                <code>docker compose pull && docker compose up -d</code> to pull
                the new image and start the containers with the new image.
            </p>
        </div>
        <h2>Feature Implementation</h2>
        <h3>1. Secured with SSL</h3>
        <div>
            <p>To secure our site will SSL, we upgrade the connection to HTTPS using nginx proxy. Our nginx instance is running on Docker as part of a stack deployement.
            Nginx has two ports open 80 (for HTTP) and 443 (for HTTPS), when a HTTP request comes in to the server, nginx will redirect the request to our app that uses HTTP.</p>
            <figure>
                <img src="/docs/nginx-config.png" alt="nginx config" />
                <figcaption>nginx config</figcaption>
            </figure>
            <p>
                The /.well-known/acme-challenge/ endpoint is used by certbot. Firstly certbot creates a token and stores it in the mentioned directory.
                Then certbot makes a request for a SSL certificate from the Let's Encrypt Certificate Authority.
                The Certificate Authority then makes a request to the server for the token file specified by certbot to verify the identity of the server.
                If the challenge passes, the Certificate Authority will issue a certificate for the domain.
                A reference to the expected certificate route is added to the nginx config file.
            </p>
            <p>
                For certificate renewal, we have a command in the <a href='#compose-image'>docker compose</a> to make certbot renew the certificate and for nginx to reload to get the new certificate.
            </p>
        </div>
        <h3>2. ReST API Documentation (OpenAPI)</h3>
        <div>
            <p>
                OpenAPI, formerly known as Swagger, is a specification for
                building APIs (Application Programming Interfaces).For this
                project, the comments with @openapi annotations are using the
                OpenAPI Specification to document the RESTful API for both
                Points of Interest (POI) and user management, which provide
                details about the available endpoints, expected request and
                response formats, authentication requirements, and potential
                error scenarios, making it easier for developers to understand
                and use the API. The URL for genrated documentation is
                <a
                    href="https://coordinated-chaos.uksouth.cloudapp.azure.com/api-docs/"
                >
                    https://coordinated-chaos.uksouth.cloudapp.azure.com/api-docs/</a
                >
            </p>
        </div>
        <h3>3. Database</h3>
        <div>
            <p>
                For the database, we chose to use MongoDB as it is a NoSQL
                database it is very flexible making it easy to add new features
                when they require new fields in the data.
            </p>
            <p>
                The database is hosted within docker, in our local testing
                environments we have the port open so that it can easily be
                accessed from a GUI like
                <a href="https://studio3t.com/">Studio 3t</a>. This helps with
                debugging.
            </p>
            <p>
                On the live deployment, it does not have its ports open, it is
                accessed by the app through a private network within Docker.
                (See the <a href="#compose-image">compose file</a> for more
                details)
            </p>
            <p>
                To interact with the database in NodeJS we are using the
                <a href="https://www.npmjs.com/package/mongoose">mongoose</a>
                npm package which is a wrapper for the official NodeJS MongoDB
                driver, making it easy to declare schemas and work with the data
                in the collections.
            </p>
        </div>
        <h3>4. Internationalisation</h3>
        <div>
            <p>
                We have implemented internationalisation using the
                <a href="https://www.npmjs.com/package/i18n">i18n</a> npm
                package. The languages used are English as default, Portuguese,
                French, Spanish, German and Turkish.
            </p>
            <p>
                "I18n.js" is used to configure i18n where is defined the default
                language, the languages supported and a cookie which is going to
                be used to store the value of the user language option. In the page
                there is a button which allows the user to change the language. 
                When the user clicks on the button, it will change the value of the cookie,
                by linking to /lang/en ,for example, and reload the page. 
                When the page is reloaded, it will be retrieved the value of the cookie, 
                which is setted by the route and change the language accordingly, then redirects the user back to index page.   
            </p>
            <p>
                Inside "locales" folder is stored the json files with the key
                strings and values of the translation that are used to translate
                the ejs pages. Each ejs page has String keys that will retrieve
                the values related to each key.
                For example, in the index.ejs file, the following string key is used to retrieve the value for the "Home" attribute: "i18n.__("Home") ".
                This key is defined in the en.json file, which contains the English translation for the "Home" string. If the user's preferred language is Portuguese, the  i18n.__ function will retrieve the value for the "Home" string from the pt.json file, which contains the Portuguese translation for the "title" string.
            </p>
        </div>
        <h3>5. Documentation</h3>
        <div>THIS IS THE DOCUMENTATION</div>
        <h3>6. GDPR</h3>
        <div></div>
        <h3>7. Server hosting and Docker</h3>
        <div>
            <h4>Azure Server</h4>
            <h4>Docker</h4>
            <figure>
                <img id="compose-image" src="/docs/compose.png" alt="compose.yml" />
                <figcaption>compose.yml</figcaption>
            </figure>
        </div>
        <h3>8. User authentication</h3>
        <div>
            <p>
                When a user attempts to log in, they provide their credentials (username and password). This information is typically entered into a form on the website.
                The login information is then sent to the server through a POST request to the /user/login endpoint. </br>The UserController.login function handles 
                the login process on the server. It verifies the user's credentials, and if they are valid, it generates an access token.The access token is then 
                sent back to the client, and the client stores this token locally, typically in the browser's local storage. This token is crucial for subsequent authenticated requests.
                If a token is found, it means the user is authenticated. The presence of the token is used to make authenticated requests to the server by including the token in the request headers.</br>
                After successful login, when the user performs actions that require authentication (e.g., updating user details), the client includes the authentication token in the headers of the fetch requests.
                The server, on its end, has middleware (such as stdAuth and adminAuth) that checks the validity of the provided token. If the token is valid, the server proceeds with the requested action.</br> 
                If not, it responds with an authentication error.The user can log out by making a GET request to the /user/logout endpoint. This triggers the UserController.logout function on the server.
                The server may invalidate the user's access token, ensuring that the user needs to log in again for future actions requiring authentication. So, when the user logs out, the client removes the token from local storage.</br>
                So, the user authentication flow involves logging in, obtaining an access token, storing the token locally, and using it for subsequent authenticated requests. The server validates the token and authorizes or rejects requests accordingly.
                The user can log out to end the authenticated session.
            </p>
        </div>
        <h3>9. User privalleges</h3>
        <div></div>
        <h3>10. Mobile access</h3>
        <div></div>
        <h3>11. Responsiveness</h3>
        <div></div>
        <h3>12. Geolocation</h3>
        <div>
            <p>
                The geolocation is implemented using the
                <a
                    href="https://developer.mozilla.org/en-US/docs/Web/API/Geolocation_API"
                >
                    Geolocation API</a
                >. When a user accesses the web application, they are prompted to share their location with the app.
                    If the user chooses to share their location, the Geolocation API retrieves data from the device's GPS hardware,
                        providing accurate latitude and longitude coordinates. These coordinates are then used to display the user's
                            current location on the map. The map is configured using Leaflet, a popular open-source JavaScript library for interactive maps.</br>

                If the user opts not to share their location, the map defaults to a predetermined location. In this case, the map remains static, and if the user
                    interacts with it by moving the point on the map, the coordinates will not be updated since geolocation data is not available.</br>
                
                For users who grant permission to use their location, a "Revoke Geolocation" button is displayed. Clicking this button allows users to revoke
                        the application's access to their location, effectively stopping the user's location marker from updating on the map. The Geolocation 
                        API provides a mechanism for users to control their privacy preferences, either by allowing or revoking access to their geographical information.</br>
            </p>
        </div>
        <h3>13. Client authentication</h3>
        <div></div>
    </body>
</html>
